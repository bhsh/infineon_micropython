/**
 * \file FlashDemo.c
 * \brief Flash erase & program Demo
 *
 * \version iLLD_Demos_1_0_1_11_0
 * \copyright Copyright (c) 2014 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or 
 * the company in which ordinary course of business you are acting and (ii) 
 * Infineon Technologies AG or its licensees. If and as long as no such 
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or 
 * organization obtaining a copy of the software and accompanying 
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the 
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include <stdio.h>
#include <string.h>
#include "Cpu0_Main.h"
#include <Cpu/Std/IfxCpu.h>
#include "Ifx_Assert.h"
#include "FlashDemo.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/
#define FLASHDEMO_PFLASH_PAGE_LENGTH 0x20          /**< \brief P Flash Page Length */

#define FLASHDEMO_PFLASH_SECTOR_NO   22            /**< \brief P Flash Sector to be erased & Programmed */
#define FLASHDEMO_PFLASH_START_PAGE  0             /**< \brief P Flash Programming starts from this page */
#define FLASHDEMO_PFLASH_NO_OF_PAGES 5             /**< \brief P Flash - No of pages to be programmed */

#define FLASHDEMO_DFLASH_SECTOR_NO   0             /**< \brief D Flash Sector to be erased & Programmed */
#define FLASHDEMO_DFLASH_START_PAGE  0             /**< \brief D Flash Programming starts from this page */
#define FLASHDEMO_DFLASH_NO_OF_PAGES 8            /**< \brief D Flash - No of pages to be programmed */

#define FLASHDEMO_RELOC_START_ADDR   (0xC0000000U) /**< \brief Program & Erase routines relocation address */

/** \brief Length of Program & Erase routines
 */
#define FLASHDEMO_ERASESECTOR_LEN    (100)
#define FLASHDEMO_WAITUNBUSY_LEN     (100)
#define FLASHDEMO_ENTERPAGEMODE_LEN  (100)
#define FLASHDEMO_LOADPAGE2X32_LEN   (100)
#define FLASHDEMO_WRITEPAGE_LEN      (100)
#define FLASHDEMO_PFLASHERASE_LEN    (0x100)
#define FLASHDEMO_PFLASHPROGRAM_LEN  (0x10C)

/** \brief Program & Erase routines relocation length */
#define FLASHDEMO_RELOC_LENGTH                                  \
    (FLASHDEMO_ERASESECTOR_LEN + FLASHDEMO_WAITUNBUSY_LEN +     \
     FLASHDEMO_ENTERPAGEMODE_LEN + FLASHDEMO_LOADPAGE2X32_LEN + \
     FLASHDEMO_WRITEPAGE_LEN + FLASHDEMO_PFLASHERASE_LEN +      \
     FLASHDEMO_PFLASHPROGRAM_LEN)

/** \brief Start addresses of Program & Erase routines
 */
#define FLASHDEMO_ERASESECTOR_ADDR   (FLASHDEMO_RELOC_START_ADDR)
#define FLASHDEMO_WAITUNBUSY_ADDR    (FLASHDEMO_ERASESECTOR_ADDR + FLASHDEMO_ERASESECTOR_LEN)
#define FLASHDEMO_ENTERPAGEMODE_ADDR (FLASHDEMO_WAITUNBUSY_ADDR + FLASHDEMO_WAITUNBUSY_LEN)
#define FLASHDEMO_LOADPAGE2X32_ADDR  (FLASHDEMO_ENTERPAGEMODE_ADDR + FLASHDEMO_ENTERPAGEMODE_LEN)
#define FLASHDEMO_WRITEPAGE_ADDR     (FLASHDEMO_LOADPAGE2X32_ADDR + FLASHDEMO_LOADPAGE2X32_LEN)
#define FLASHDEMO_PFLASHERASE_ADDR   (FLASHDEMO_WRITEPAGE_ADDR + FLASHDEMO_WRITEPAGE_LEN)
#define FLASHDEMO_PFLASHPROGRAM_ADDR (FLASHDEMO_PFLASHERASE_ADDR + FLASHDEMO_PFLASHERASE_LEN)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
App_Pflash g_Pflash; /**< \brief PFlash global data */
App_Dflash g_Dflash; /**< \brief DFlash global data */

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/
static void PFlashErase(uint32 flash, uint32 sector_addr);
static void PFlashProgram(uint32 flash, uint32 sector_addr, uint32 start_page, uint32 no_of_pages);
/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
/** \brief copyFlashRoutinesToPspr
 *
 * This function copies the erase and program routines to PSPR memory
 */
static void copyFlashRoutinesToPspr(void)
{
    /*
     * Copy the below Flash routines to PSPR memory & assign a function pointer
     * IfxFlash_eraseSector, IfxFlash_waitUnbusy, IfxFlash_enterPageMode, IfxFlash_loadPage2X32, IfxFlash_writePage
     * PFlashErase, PFlashProgram
     */
    memcpy((void *)FLASHDEMO_ERASESECTOR_ADDR, (const void *)IfxFlash_eraseSector, FLASHDEMO_ERASESECTOR_LEN);
    g_Pflash.command.eraseSector = (void *)FLASHDEMO_RELOC_START_ADDR;

    memcpy((void *)FLASHDEMO_WAITUNBUSY_ADDR, (const void *)IfxFlash_waitUnbusy, FLASHDEMO_WAITUNBUSY_LEN);
    g_Pflash.command.waitUnbusy = (void *)FLASHDEMO_WAITUNBUSY_ADDR;

    memcpy((void *)FLASHDEMO_ENTERPAGEMODE_ADDR, (const void *)IfxFlash_enterPageMode, FLASHDEMO_ENTERPAGEMODE_LEN);
    g_Pflash.command.enterPageMode = (void *)FLASHDEMO_ENTERPAGEMODE_ADDR;

    memcpy((void *)FLASHDEMO_LOADPAGE2X32_ADDR, (const void *)IfxFlash_loadPage2X32, FLASHDEMO_LOADPAGE2X32_LEN);
    g_Pflash.command.loadPage2X32 = (void *)FLASHDEMO_LOADPAGE2X32_ADDR;

    memcpy((void *)FLASHDEMO_WRITEPAGE_ADDR, (const void *)IfxFlash_writePage, FLASHDEMO_WRITEPAGE_LEN);
    g_Pflash.command.writePage = (void *)FLASHDEMO_WRITEPAGE_ADDR;

    memcpy((void *)FLASHDEMO_PFLASHERASE_ADDR, (const void *)PFlashErase, FLASHDEMO_PFLASHERASE_LEN);
    g_Pflash.command.pFlashErase = (void *)FLASHDEMO_PFLASHERASE_ADDR;

    memcpy((void *)FLASHDEMO_PFLASHPROGRAM_ADDR, (const void *)PFlashProgram, FLASHDEMO_PFLASHPROGRAM_LEN);
    g_Pflash.command.pFlashProgram = (void *)FLASHDEMO_PFLASHPROGRAM_ADDR;
}


/** \brief PFlashErase
 *
 * This function will erase the P-Flash Sector
 * Note: This function shouldn't be executed from Flash it is trying to erase.
 * Recommended to execute the routine from PSPR memory
 */
static void PFlashErase(uint32 flash, uint32 sector_addr)
{
    uint16 endinitSfty_pw;
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /* Erase the sector */
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);
    g_Pflash.command.eraseSector(sector_addr);
    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);

    /* wait until unbusy */
    g_Pflash.command.waitUnbusy(flash, g_Pflash.flashType);
}


/** \brief PFlashProgram
 *
 * This function will program the P-Flash Sector
 * Note: This function shouldn't be executed from Flash it is trying to program.
 * Recommended to execute the routine from PSPR memory
 */
static void PFlashProgram(uint32 flash, uint32 sector_addr, uint32 start_page, uint32 no_of_pages)
{
    uint32 offset;
    uint32 page;
    uint16 endinitSfty_pw;
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /* program the given no of pages */
    for (page = start_page; page < no_of_pages; ++page)
    {
        uint32 pageAddr = sector_addr + page * FLASHDEMO_PFLASH_PAGE_LENGTH;
        g_Pflash.command.enterPageMode(pageAddr);

        /* wait until unbusy */
        g_Pflash.command.waitUnbusy(flash, g_Pflash.flashType);

        /* write 32 bytes (8 doublewords) into assembly buffer */
        for (offset = 0; offset < FLASHDEMO_PFLASH_PAGE_LENGTH; offset += 8)
        {
            g_Pflash.command.loadPage2X32(pageAddr, pageAddr, offset);
        }

        /* write page */
        IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);
        g_Pflash.command.writePage(pageAddr);
        IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);

        /* wait until unbusy */
        g_Pflash.command.waitUnbusy(flash, g_Pflash.flashType);
    }
}


/** \brief P-Flash Demo
 *
 * This function is called from the run to demo the P-Flash Erase & Program functionality
 */
static void PFlashDemo(void)
{
    uint32  errors      = 0;
    uint32  offset;
    uint32  page        = 0;
    uint32  flash       = 0;
    uint32  sector_addr = IfxFlash_pFlashTableLog[g_Pflash.sector].start;

    /* disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();

    /* Copy the erase and program routines to PSPR memory */
    copyFlashRoutinesToPspr();

    /* erase & program flash (execute from relocated memory)*/
    g_Pflash.command.pFlashErase(flash, sector_addr);
    g_Pflash.command.pFlashProgram(flash, sector_addr, g_Pflash.startPage, g_Pflash.numberOfPages);

    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);

    /* Verify the programmed data */
    for (page = g_Pflash.startPage; page < g_Pflash.numberOfPages; ++page)
    {
        uint32          pageAddr = sector_addr + page * FLASHDEMO_PFLASH_PAGE_LENGTH;
        volatile uint8 *addr     = (uint8 *)pageAddr;

        for (offset = 0; offset < FLASHDEMO_PFLASH_PAGE_LENGTH; offset += 8)
        {
            if (!((pageAddr == *((uint32 *)(addr + offset))) &&
                  (addr[offset + 4] == offset)))
            {
                errors++;
            }
        }
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, errors == 0);

    if (errors)
    {
        printf("ERROR: error while P-Flash erase / program\n");
    }
    else
    {
        printf("OK: P-Flash checks passed\n");
    }
}


/** \brief D-Flash Demo
 *
 * This function is called from the run to demo the D-Flash Erase & Program functionality
 */
static void DFlashDemo(void)
{
    uint32 errors = 0;
    uint16 endinitSfty_pw;
    uint32 offset;
    uint32 page;
    uint32 flash       = 0;
    uint32 sector_addr = IfxFlash_dFlashTableEepLog[g_Dflash.sector].start;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    /* erase program flash */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
    IfxFlash_eraseSector(sector_addr);
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    /* wait until unbusy */
    IfxFlash_waitUnbusy(flash, g_Dflash.flashType);
    printf("OK: D-Flash Erase \n");

    /* program the given no of pages */
    for (page = g_Dflash.startPage; page < g_Dflash.numberOfPages; ++page)
    {
        uint32 pageAddr = sector_addr + page * IFXFLASH_DFLASH_PAGE_LENGTH;
        errors = IfxFlash_enterPageMode(pageAddr);

        /* wait until unbusy */
        IfxFlash_waitUnbusy(flash, g_Dflash.flashType);

        IfxFlash_loadPage2X32(pageAddr, pageAddr, page);
        /* write page */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        IfxFlash_writePage(pageAddr);
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

        /* wait until unbusy */
        IfxFlash_waitUnbusy(flash, g_Dflash.flashType);
    }
    printf("OK: D-Flash Program \n");

    /* Verify the programmed data */
    for (page = g_Dflash.startPage; page < g_Dflash.numberOfPages; ++page)
    {
        uint32          pageAddr = sector_addr + page * IFXFLASH_DFLASH_PAGE_LENGTH;
        volatile uint8 *addr     = (uint8 *)pageAddr;

        for (offset = 0; offset < IFXFLASH_DFLASH_PAGE_LENGTH; offset += 8)
        {
            if (!((pageAddr == *((uint32 *)(addr))) &&
                  (addr[4] == page)))
            {
                errors++;
            }
        }
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, errors == 0);

    if (errors)
    {
        printf("ERROR: error while D-Flash erase / program\n");
    }
    else
    {
        printf("OK: D-Flash checks passed\n");
    }
}


/** \brief Demo init API
 *
 * This function is called from main during initialization phase
 */
void IfxFlashDemo_init(void)
{
#if 0
    /* Initialise the P Flash global data */
    g_Pflash.sector        = FLASHDEMO_PFLASH_SECTOR_NO;
    g_Pflash.startPage     = FLASHDEMO_PFLASH_START_PAGE;
    g_Pflash.numberOfPages = FLASHDEMO_PFLASH_NO_OF_PAGES;
    g_Pflash.flashType     = IfxFlash_FlashType_P0;
#endif
    /* Initialise the D Flash global data */
    g_Dflash.sector        = FLASHDEMO_DFLASH_SECTOR_NO;
    g_Dflash.startPage     = FLASHDEMO_DFLASH_START_PAGE;
    g_Dflash.numberOfPages = FLASHDEMO_DFLASH_NO_OF_PAGES;
    g_Dflash.flashType     = IfxFlash_FlashType_D0;
}


/** \brief Demo run API
 *
 * This function is called from main, background loop
 */
void IfxFlashDemo_run(void)
{
    //YP PFlashDemo();
    DFlashDemo();
}

IfxFlash_programme_dflash(unsigned int destpageaddr,unsigned int           wordL, unsigned int wordU)
{
  uint32 errors = 0;
  uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
  uint32 offset;
  uint32 page;
  uint32 flash		 = 0;

  uint32 pageAddr = destpageaddr;//sector_addr + page * IFXFLASH_DFLASH_PAGE_LENGTH;
  errors = IfxFlash_enterPageMode(pageAddr);
  
  /* wait until unbusy */
  IfxFlash_waitUnbusy(flash, g_Dflash.flashType);
  
  IfxFlash_loadPage2X32(pageAddr, wordL, wordU);
  /* write page */
  IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
  IfxFlash_writePage(pageAddr);
  IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
  
  /* wait until unbusy */
  IfxFlash_waitUnbusy(flash, g_Dflash.flashType);
}

void IfxFlash_erase_dflash(unsigned char sector,unsigned char sector_num)
{
  uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
  uint32 sector_addr,j;
  uint32 flash          = 0;

  for(j = sector ; j < (sector_num + sector); j++)
  { 
      sector_addr    = IfxFlash_dFlashTableEepLog[j].start;
	  
	  /* erase Date flash */
	  IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
	  IfxFlash_eraseSector(sector_addr);
	  IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

      /* wait until unbusy */
      IfxFlash_waitUnbusy(flash, g_Dflash.flashType);
  }
}

